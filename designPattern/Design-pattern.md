# Design Pattern

디자인 패턴은 오랫동안 다수의 검증을 거친 프로그래밍 패턴이다.
프로그램으로 문제를 해결할때 각 문제의 타입별로 해결하기 좋은 프로그래밍 패턴들이 존재한다는 것이 알려졌고, 여기에 이름이들이 붙여졌다.
이 패턴들은 객체지향으로 프로그램을 설계할때 매우 유용하게 사용된다.

* Strategy Pattern
* Observer Pattern
* Decorator Pattern

그리고 이 디자인패턴에는 객체지향 원칙이 적용된다.

> ## 객체지향 원칙
> 
> * 바뀌는 부분은 `캡슐화`한다.
> * 상속보다는 `구성(인스턴스 변수로 다른 객체를 저장하는 방식)`을 활용한다.
> * 구현이 아닌 `인터페이스`에 맞춰서 프로그래밍한다.
> * 서로 상호작용하는 객체 사이에는 가능하면 `느슨한 결합` 디자인을 사용한다.
> * 클래스는 확장에 대해서는 열려있지만 변경에 대해서는 닫혀있어야 한다. (`Open-Close Principal`)

## Strategy Pattern
알고리즘군을 정의하고 각각을 캡슐화하여 바꿔 쓸 수 있게 만든 디자인 패턴.
* 객체의 행동패턴 중에 한가지 패턴.
* 알고리즘을 사용하는 클라이언트와는 독립적으로 알고리즘을 변경할 수 있음.

## Observer Pattern
한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들에게 연락이 가고, 자동으로 내용이 갱신되는 디자인 패턴.
* 객체들 사이의 `1 to Many`관계를 정의한다.
* Observable에서 data를 보내거나(푸시 방식) Observer가 data를 가져오는(풀 방식)을 사용할 수 있다.
* java.util.Observable 을 비롯해 `Observer Pattern` 을 구현한 것은 여럿 있다.
* java.util.Observable 은 `class` 이다. 필요하면 `interface`를 직접 구현하여 사용하자.

## Decorator Pattern
객체에 추가 요소를 동적으로 더할 수 있는 디자인 패턴.
* 서브 클래스를 만드는 것보다 훨씬 유연하게 기능을 `확장`할 수 있다.
* Decorator 클래스의 형식은 그 클래스가 감싸고 있는 클래스의 형식을 반영한다.
* 이 패턴에서는 자기가 감싸고 있는 구성요소의 메서드를 호출한 결과에 새로운 기능을 더함으로써 행동을 확장한다.
* 일반적으로 이 패턴을 사용하는 클라이언트 입장에서는 Decorator의 존재를 알 수 없다. (구성 요소의 구체적 형식에 클라이언트가 의존적이라면 알 수 있다.)
* Decorator를 너무 많이 사용하면 자잘한 객체들이 많이 추가되고, 코드가 필요 이상으로 복잡해질 수 있다.

> 본 저장소의 코드는 'Head First Design Patterns'의 실습 코드이다.
> 본 저장소의 코드는 JDK 9.0 기반으로 작성되었다.